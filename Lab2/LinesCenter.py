# Для градієнту
EPS = 1e-6
# Початковий крок
START_LR = 200
# Кількість ітерацій
ITER_NUM = 500


# Шукаємо довжину вектора
def dist(a, b):
    return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2) ** 0.5


# Відстань від точки до відрізку
def dist_to_segment(a, b, p):
    # Координати нашої точки
    x, y, z = p

    # Пошук проекції
    projection = ((x - a[0]) * (b[0] - a[0]) + (y - a[1]) * (b[1] - a[1]) + (z - a[2]) * (b[2] - a[2])) / \
                 ((b[0] - a[0]) ** 2 + (b[1] - a[1]) ** 2 + (b[2] - a[2]) ** 2) ** 0.5

    # Якщо проекція в іншу сторону (за межі лінії), тоді ми запускаємо знову цю функцію, тільки напрям лінії міняємо
    # в іншу сторону
    if projection < 0:
        return dist_to_segment(b, a, p)

    # Довжина нашого вектора лінії
    segment_len = dist(a, b)

    # Якщо довжина проекції в межах вектора лінії тоді шукаємо відстань за теоремою піфагора
    if segment_len > projection:

        # Вектор від краю нашої лінії до точки
        ap = dist(a, p)

        if ap ** 2 - projection ** 2 < 0:
            print(a, b, p)
        return (ap ** 2 - projection ** 2) ** 0.5

    # В інакшому випадку, беремо найменшу з двох відстаней від точки до країв лінії
    else:
        return min(dist(p, a), dist(p, b))


# Функція пошуку градієнту
def gradients(F, a):
    global EPS
    res = []

    # Заповнюємо масив res нулями
    for i in range(len(a)):
        res.append(0)

    for i in range(len(a)):
        b = []

        # Копіюємо координа точки а для подальшого порівняння
        for ai in a:
            b.append(ai)

        # Додаємо EPS до нових координат
        b[i] += EPS

        # Пошук чисельної похідної функції
        res[i] = (F(b) - F(a)) / EPS

    # Знаходимо довжину вектора
    d = sum(k ** 2 for k in res) ** 0.5

    # Якщо довжина вектора нульова, тоді ми прибули в нашу точку призначення
    if d == 0:
        return res

    # Інакше повертаємо одиничний вектор (його координати)
    return list(map(lambda x: x / d, res))


# Рухаємо точку х для мінімізації функції з даним кроком
def move(x, f, step_size=0.1):
    # Ініціалізуємо ліст для вектора зсуву
    move_vec = []

    # Домножуємо одиничний вектор на крок
    for k in gradients(f, x):
        move_vec.append(k * step_size)

    # Міняємо знак кожного елементу ліста векторів зсуву
    for i in range(len(move_vec)):
        x[i] -= move_vec[i]
    return x


# Вводимо кількість ліній
N = int(input())

# Ліст з нашими лініями
segments = []


# Функція відстаней, яку нам потібно мінімізувати
def func(x):
    global segments
    res = 0
    for s in segments:
        # Сумарна відстань від актуальної точки до усіх ліній, яку ми мінімізовуємо
        res += dist_to_segment(*s, x)
    return res


# Зчитування координат кожної лінії
for i in range(N):
    x1, y1, z1, x2, y2, z2 = map(int, input().split())
    segments.append(((x1, y1, z1), (x2, y2, z2)))

# Ініціалізуємо попередню ітерацію
last = 0

# Початкове наближення (вибираємо рандомно)
x = [10, 10, 10]

# Епохи - кожен наш крок, зсув точки до точки мінімуму
for epoch in range(ITER_NUM):

    # Функція, яка переміжає точку на певний крок
    move(x, func, step_size=START_LR)
    this = func(x)

    # Перевірка, чи ця ітерація не більша за попередню, якщо так, то ми проскочили нашу точку і зменшуємо крок вдвіччі
    if last < this:
        START_LR *= 0.5

    # Присвоюємо цю ітерацію попередній
    last = this

print(last)
